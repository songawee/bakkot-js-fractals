<html> <head>  <script type="application/x-javascript">//Two user-configurable variables.var totIters = 0var scale = 500;//Start stuff, used in every canvas thing.  var canvas;var ctx;var giantAr;function draw() {	canvas = document.getElementById("canvas");	ctx = canvas.getContext("2d");	ctx.fillStyle = "rgb(0,0,0)";	//invoke start function here    canvas.onclick=iter;    document.onkeypress=keypressed;    getStarted()}//This function draws a line. It's more complex than you'd expect because it a.) inverts the graph, so 0,0 is in the bottom left, not top, b.) scales the graph (because until this point nothing is above 2,2)function drawLine(startCoords, endCoords) {	startCoords = [startCoords.split(",")[0]*scale,startCoords.split(",")[1]*scale*(-1)+scale*Math.sqrt(3)/2]	endCoords = [endCoords.split(",")[0]*scale,endCoords.split(",")[1]*scale*(-1)+scale*Math.sqrt(3)/2]	ctx.beginPath();	ctx.moveTo(startCoords[0], startCoords[1]);	ctx.lineTo(endCoords[0], endCoords[1]);	ctx.stroke()}//You pass this function a number represented by a string and it returns it as a number. Useful when invoked as array.map(makenums), because it does it for all strings in the array.function makeNums(v) {  return v*1}//This is the mathy part. Given two points and one reference, it works out where the third point is which would form an equilateral triangle with the other two. The reference point is so that it can work out which of the two possible ones to use it wants (it wants the one farther away).function makeTri(start, end, cent) {  start = start.split(",")  end = end.split(",")  cent = cent.split(",")    theta = Math.atan2(end[1]-start[1],end[0]-start[0])  theta += Math.PI/3    r = Math.sqrt(Math.pow(start[0]-end[0],2) + Math.pow(start[1]-end[1],2))  newX = start[0]*1  newX += r * Math.cos(theta)    newY = start[1]*1  newY += r * Math.sin(theta)  newCo1 = newX+","+newY    newCo1Dis = Math.sqrt(Math.pow(cent[0]-newX,2) + Math.pow(cent[1]-newY,2))  newX = end[0]*1  newX -= r * Math.cos(theta)    newY = end[1]*1  newY -= r * Math.sin(theta)  newCo2 = newX+","+newY    newCo2Dis = Math.sqrt(Math.pow(cent[0]-newX,2) + Math.pow(cent[1]-newY,2))  if(newCo1Dis < newCo2Dis) {    //drawTri([start.join(), newCo2, end.join()])    return [start.join(), newCo2, end.join()]  }    else if(newCo1Dis > newCo2Dis) {    //drawTri([start.join(), newCo1, end.join()])    return [start.join(), newCo1, end.join()]  }    else    alert("What the fudge, mate?")}//Given the coordinates of an equilateral triangle, this works out where the center is by averaging their x values, and their y values.function findCenter(l, r, t) {  l=l.split(",").map(makeNums)  r=r.split(",").map(makeNums)  t=t.split(",").map(makeNums)  c= ((l[0]+r[0]+t[0])/3).toString() + "," + ((l[1]+r[1]+t[1])/3).toString()  return c}//This function is run on each element of an array. If that element is an array containing more arrays, it calls itself on that element. If, however, it is an array containing strings (always coordinate strings), it draws a line between the first two in that array.function drawIterate(v, i, a) {  if(typeof(v[0]) == "object") {    v.forEach(drawIterate)  }  else {    drawLine(v[0], v[1])  }}//This function is run on each element of an array. If that element is an array containing more arrays, it calls itself on that element. If, however, it is an array containing strings, it calls getThird on that array.function iterate(v, i, a) {  if(typeof(v[0]) == "object") {    v.forEach(iterate)  }  else    a[i] = getThird(v[0], v[1], v[2])}//This is another important function. Read the comments inside to see what it does.function getThird(l, r, c) {  l=l.split(",").map(makeNums)  r=r.split(",").map(makeNums)    //This bit finds one third of the way from the first point to the second and two thirds of the way. Simple enough.  oneThird = [l[0]+(r[0]-l[0])/3, l[1]+(r[1]-l[1])/3].join()  twoThird = [l[0]+(r[0]-l[0])/3*2, l[1]+(r[1]-l[1])/3*2].join()    //This invokes makeTri (see above) on the things it just found.  newPoint = makeTri(oneThird, twoThird, c)[1]    //Self-explanatory.  newCent = findCenter(oneThird, twoThird, newPoint)    //These are the arrays of coordinate sets, each representing a line. The third one is a reference point for makeTri.  firstAr = [l.join(), oneThird, c]  secondAr = [oneThird, newPoint, newCent]  thirdAr = [newPoint, twoThird, newCent]  fourthAr = [twoThird, r.join(), c]    return [firstAr, secondAr, thirdAr, fourthAr]}function getStarted() {  canvas.height = scale*2*Math.sqrt(3)/3+1  canvas.width = scale+1  //Finds the top and center points of the triangle formed with 0,0 and 1,1. The third value in the first one is arbitary - the only important part is that it is under the line, so the triangle it gives you is above it.    topP = makeTri("0,0", "1,0", ".5,-1")[1]  bigC = findCenter("0,0", "1,0", topP)    //Right now, this contains the arrays of coordinate strings representing the three sides of the starting triangle. It eventually contains everything.  giantAr = [["0,0", topP, bigC], [topP, "1,0", bigC], ["1,0", "0,0", bigC]]    //Calls the drawing function once we're done.  giantAr.forEach(drawIterate)}function iter() {  ctx.clearRect(0,0,scale+1,scale*2*Math.sqrt(3)/3+1)  giantAr.forEach(iterate)  giantAr.forEach(drawIterate)}function reset() {  ctx.clearRect(0,0,scale+1,scale*2*Math.sqrt(3)/3+1)  getStarted()}function keypressed(e) {  if(String.fromCharCode(e.which)=="s") {    scale = prompt('Set the scale to...', scale)*1  }  if(String.fromCharCode(e.which)=="r" || String.fromCharCode(e.which)=="s") {    reset()  }} </script> </head> <body onload="draw()"> 	A demonstration of the <a href="http://en.wikipedia.org/wiki/Koch_snowflake">Koch snowflake</a>. Click to iterate. 	<br><br><br>   <canvas id="canvas" width="1" height="1"></canvas> </body></html>