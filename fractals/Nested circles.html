<html> <head>  <script type="application/x-javascript">  var canvas;var ctx;var scale = 300;var giantAr = [];var bigC = []var iRatio = .37var iternum = 0;var iternum2 = 1;var rAngle = 60;function draw() {	canvas = document.getElementById("canvas");	ctx = canvas.getContext("2d");	ctx.fillStyle = "rgb(0,0,0)";	canvas.height = scale*2+2	canvas.width = scale*2+2    canvas.onclick=iter;    document.onkeypress=reset;    ctx.translate(scale+1, scale+1)    rAngle = Math.PI*rAngle/180	//invoke start function here    getStarted()}function drawCircle(ar) {  ctx.beginPath();  ctx.arc(ar[0]*scale,ar[1]*-scale,ar[2]*scale,0,Math.PI*2,true);  ctx.stroke()}function drawLine(ar, ar1) {  ctx.beginPath();  ctx.moveTo(ar[0]*scale, ar[1]*-scale);  ctx.lineTo(ar1[0]*scale, ar1[1]*-scale);  ctx.stroke()}function sq(v) {  return v*v}function getStarted() {  bigC = [0, 0, 1]    width1 = iRatio  width2 = 1-iRatio      giantAr = [[[-width1*Math.cos(rAngle),-width1*Math.sin(rAngle),width2],[width2*Math.cos(rAngle)-0.00002,width2*Math.sin(rAngle),width1], "B"]]  drawCircle(giantAr[0][0])  drawCircle(giantAr[0][1])  drawCircle(bigC)}function doMatrix(coefs, rhs) {  for (var i = 0; i < 2; i++) {    for (var col = i + 1; col < 3; col++)      coefs[i][col] /= coefs[i][i];    rhs[i] /= coefs[i][i];    coefs[i][i] = 1;    for (var row = 0; row < 3; row++) {      if (row != i) {        for (var col = i + 1; col < 3; col++)          coefs[row][col] -= coefs[row][i] * coefs[i][col];        rhs[row] -= coefs[row][i] * rhs[i];        coefs[row][i] = 0;      }    }  }  return [coefs, rhs]}function caseOne(ar, b) {  function plusminus(arg1, arg2, rev) {    if((b || rev) && !(b && rev))      return arg1 + arg2    else      return arg1 - arg2  }  var aOne = [2*ar[0][0] - 2*ar[1][0], 2*ar[0][1] - 2*ar[1][1], 2*ar[0][2] + 2*ar[1][2]]  var aTwo = [2*ar[0][0] - 2*ar[2][0], 2*ar[0][1] - 2*ar[2][1], plusminus(2*ar[0][2], 2*ar[2][2])]  var aThr = [2*ar[1][0] - 2*ar[2][0], 2*ar[1][1] - 2*ar[2][1], plusminus(2*ar[1][2], 2*ar[2][2])]  var a = [aThr, aTwo, aOne]  var cOne = ar[0][0]*ar[0][0] - ar[1][0]*ar[1][0] + ar[0][1]*ar[0][1] - ar[1][1]*ar[1][1] - ar[0][2]*ar[0][2] + ar[1][2]*ar[1][2]  var cTwo = ar[0][0]*ar[0][0] - ar[2][0]*ar[2][0] + ar[0][1]*ar[0][1] - ar[2][1]*ar[2][1] - plusminus(ar[0][2]*ar[0][2], ar[2][2]*ar[2][2], 1)  var cThr = ar[1][0]*ar[1][0] - ar[2][0]*ar[2][0] + ar[1][1]*ar[1][1] - ar[2][1]*ar[2][1] - plusminus(ar[1][2]*ar[1][2], ar[2][2]*ar[2][2], 1)  var c = [cThr, cTwo, cOne]        inter = doMatrix(a, c)  p = inter[0]  q = inter[1]    A = (sq(p[0][2]) + sq(p[1][2]) - 1)  B = (2*ar[2][0]*p[0][2] - 2*q[0]*p[0][2] + 2*ar[2][1]*q[1]*p[1][2] - plusminus(2*q[1]*p[1][2], 2*ar[2][2], 1))  C = (sq(ar[2][0]) - 2*ar[2][0]*q[0] + sq(q[0]) + sq(ar[2][1]) - 2*ar[2][1]*q[1] + sq(q[1]) - sq(ar[2][2]))      n1 = (-B+Math.sqrt( sq(B) - 4*A*C))/(2*A)  n2 = (-B-Math.sqrt( sq(B) - 4*A*C))/(2*A)    var h1, k1, c1, h2, k2, c2;  h1 = q[0] - p[0][2]*n1  k1 = q[1] - p[1][2]*n1    h2 = q[0] - p[0][2]*n2  k2 = q[1] - p[1][2]*n2  c1 = [h1, k1, n1]  c2 = [h2, k2, n2]  if(n1>n2 && iternum != 0) {    drawCircle(c2)    return [[ar[0], c2, "B"], [ar[1], c2, "B"], [ar[0], ar[1], c2]]  }  else if(n2>n1 && iternum != 0) {    drawCircle(c1)    return [[ar[0], c1, "B"], [ar[1], c1, "B"], [ar[0], ar[1], c1]]  }  else {    drawCircle(c1)    drawCircle(c2)    return [[[ar[0], c1, "B"], [ar[1], c1, "B"], [ar[0], ar[1], c1]], [[ar[0], c2, "B"], [ar[1], c2, "B"], [ar[0], ar[1], c2]]]  }}function caseTwo(ar) {  function descarte(r1, r2, r3) {    k1 = 1/r1    k2 = 1/r2    k3 = 1/r3    return 1/(k1 + k2 + k3 + 2*Math.sqrt(k1*k2+k2*k3+k3*k1))  }  n = descarte(ar[0][2], ar[1][2], ar[2][2])    s1 = calcDist(ar[0], ar[1])  s2 = ar[0][2]+n  s3 = ar[1][2]+n    a1 = Math.acos((s3.square()-s1.square()-s2.square())/(-2*s1*s2))  a2 = calcAngle(ar[0], ar[1])    na1 = a2-a1  nc1 = pFromAPD(na1, ar[0], s2)  na2 = a2+a1  nc2 = pFromAPD(na2, ar[0], s2)    nc = calcClosest(ar[2], nc1, nc2)    ncirc = [nc[0], nc[1], n]  drawCircle(ncirc)  return [[ar[0], ar[1], ncirc], [ar[0], ncirc, ar[2]], [ar[1], ncirc, ar[2]]]}//Passed array of three circle description arrays (or not.)function iterate(v, i, a) {  if(typeof(v[0][0]) == "number") {    //alert(i)    if(v[2] == "B")      a[i] = caseOne([v[0], v[1], bigC], true)    else      a[i] = caseTwo([v[0], v[1], v[2]], false)  }  else    a[i].forEach(iterate)}function iterLoop(iters) {  while(iternum<iters) {    giantAr.forEach(iterate)    iternum ++  }}// Calculation functionsfunction calcLine(p1, p2) {  m = (p2[1] - p1[1]) / (p2[0]-p1[0])  b = -m * p1[0] + p1[1]  return [m, b]}function calcInter(l1, l2) {  x = (l2[1] - l1[1]) / (l1[0] - l2[0])  y = l2[0] * x + l2[1]  return [x, y]}function calcMidpoint(p1, p2) {  x = (p1[0]+p2[0])/2  y = (p1[1]+p2[1])/2  return [x, y]}function calcDist(p1, p2) {  return Math.sqrt(sq(p1[0]-p2[0]) + sq(p1[1]-p2[1]))}function calcLineCircInt(line, circ) {  m = line[0]  b = line[1]  h = circ[0]  k = circ[1]  r = circ[2]    x1 = ((2*h-2*m*b+2*m*k) + Math.sqrt(sq(-2*h+2*m*b-2*m*k) - (4*sq(m)+4)*(sq(h)+sq(b)+sq(k)-sq(r)-2*b*k)))/(2*sq(m)+2)  x2 = ((2*h-2*m*b+2*m*k) - Math.sqrt(sq(-2*h+2*m*b-2*m*k) - (4*sq(m)+4)*(sq(h)+sq(b)+sq(k)-sq(r)-2*b*k)))/(2*sq(m)+2)    y1 = m*x1+b  y2 = m*x2+b    return[[x1,y1],[x2,y2]]}function calcClosest(ref, p1, p2) {  dist1 = calcDist(ref, p1)  dist2 = calcDist(ref, p2)  if(dist1 < dist2)    return p1  else if(dist2 < dist1)    return p2  else    return ref }function calcThreePointCirc(p1, p2, p3) {  m1 = -1/calcLine(p1, p2)[0]  tMid = calcMidpoint(p1, p2)  b1 = tMid[1]-m1*tMid[0]    m2 = -1/calcLine(p3, p2)[0]  tMid = calcMidpoint(p3, p2)  b2 = tMid[1]-m2*tMid[0]  lInt = calcInter([m1, b1],[m2,b2])  return [lInt[0], lInt[1], calcDist(lInt, p1)]}function calcAngle(p2, p1) {  return Math.atan2(p1[1]-p2[1], p1[0]-p2[0])}function square() {  return this*this;}Number.prototype.square = square;function pFromAPD(a, p, d) {  //That is, find the two points a given distance away from a given point on a given angle.  x = p[0]  y = p[1]  x2 = d * Math.cos(a) + x  y2 = d * Math.sin(a) + y  return [x2, y2]}var hided = false;function reset(e) {  char = String.fromCharCode(e.which);  if(char=="s") {    ctx.translate(-scale-1, -scale-1)    scale = prompt('Set the scale to...', scale*2)*1/2	canvas.height = scale*2+2	canvas.width = scale*2+2    ctx.translate(scale+1, scale+1)  }  if(char=="i") {    iRatio = prompt('Set the ratio to...', iRatio)*1  }  if(char=="a") {    rAngle = prompt('Set the rotation (in degrees) to...', Math.round(rAngle*180/Math.PI))*Math.PI/180  }  if(char=="r" || char=="s" || char=="i" || char=="a") {    ctx.clearRect(-canvas.width,-canvas.height,2*canvas.width,2*canvas.height)    iternum = 0;    iternum2 = 1;    getStarted();  }  else if(char=="h") {    if(hided) {      document.body.appendChild(hided);      hided = false;    }    else {      hided = document.body.removeChild(tform)    }  }}function iter() {  //ctx.clearRect(-canvas.width,-canvas.height,canvas.width,canvas.height)  //giantAr.forEach(iterate)  //h0.forEach(drawIterate)  iterLoop(iternum2)  iternum2++;}  </script> </head> <body onload="draw()">   <canvas id="canvas" width="1" height="1"></canvas>   <form id="tform">   Controls:<br>   click - iterate.<br>   r - reset to original circles.<br>   s - set the scale, in pixels.<br>   i - set the ratio between the two inner circles. (Between zero and one, exclusive.)<br>   a - set the angle of rotation, in degrees. (0 and 180 will break it, though.)<br>   h - hide or show this text.<br>   </form> </body></html>